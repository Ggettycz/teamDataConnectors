const {mysql,DBLink} = require('./mysql_creds.js');
const {FileExport} = require ('./elements/FileExport.js')
const logMessage = require('../src/utils.js/logs.js');
global.specificLogName = 'runExport';


const connectorTypes = 'DataExport';
const STATS_RECORD = 64; // value for DataRecordStatus generated by StatsCreate. why 64? why not 

(async function(){
    // simple select so no transaction needed.
    const link = new DBLink();

    let query  = "SELECT UUID as uuid, Name as connectorName, ConnectorType as connectorType,"
        + " Configuration as Configuration FROM Connectors"
        + " WHERE Active=1 ";//AND NextRun < NOW()";
    if (connectorTypes != '') {
        query += " AND ConnectorType in ( ? )";
    }

    let rows = await link.query(query,[connectorTypes]);	//Do qry
    let dry_run = false;

    for (const row of rows) {
        const {uuid, connectorType, connectorName} = row;
        logMessage('--------- start of new Connector for ' + uuid, 'INFO');
        logMessage('Loaded configuration:' + row['Configuration'], 'DEBUG');
        let configuration = {};
        try {
            logMessage('trying to parse configuraiton', 'TRACE');
            configuration = JSON.parse(row['Configuration']);

        } catch (e) {
            logMessage('No or wrong configuration', 'WARN');
            configuration = {};
        }
        // run connector based on the type
        if (connectorType == 'DataExport') {

            logMessage('conf:' + JSON.stringify(configuration,null,2));
            try{
                const connector = new FileExport(link, uuid, connectorName, configuration);
                //connector.helper('dbStatsNotActiveStatsCreated'); break;
                //await link.begin();
                let finished = false;
                while (!finished) {

                    if (! await connector.verifyConfiguration()) { continue; }
                    logMessage('configuration verified', 'DEBUG');
                    if (!await connector.storeRunStatus('Start')) {
                        logMessage('Issue with storing the Connector Run Status');
                    }
                    // get data to be exported ... 
                    const records= await connector.getRecordsToBeProcessed();
                    const numberOfRecords = records.length;
                    let failedRows = 0;
                    logMessage('got records to be processed:' + numberOfRecords,'DEBUG');
                    if (numberOfRecords>0) {
                        const fileStructure = connector.prepareBasicStructure(records);
                        // store them to correct path/file
                        if (! await connector.exportDataToFile(fileStructure.export)) { continue; }
                        // delete rows from table if requied
                        //logMessage('done, counting rest', 'INFO'); ///REMOVE
    
                        if (configuration.deleteAfterExport) {
                            failedRows =  numberOfRecords - await connector.deleteProcessedData();
                            if (failedRows > 0) {
                                logMessage('There was some issue in deleting data');
                            }
                        }
    
                        await connector.compressExportedFile();
                        // -- connector.helper('getParamIDsCount');
                    } else {
                        logMessage('Nothing to export end of connector run','INFO');
                    }
    
                    let result = await connector.finishRun(numberOfRecords,failedRows);
                    let valid = (result.insertId !== undefined); 
                    if (!valid) { logMessage('Status of finished run not properly stored', 'ERROR'); }
                    const nextRun = (numberOfRecords<configuration.recordsLimit)? 12:0;
                    logMessage(`Number of processed (${numberOfRecords}) x limit: (${configuration.recordsLimit}), nextRun: ${nextRun}`,'DEBUG');
                    result = await connector.updateNextRun(nextRun);
                    if ((result.changedRows!=1) || (result.warningCount!=0)) {
                        logMessage('Result of Run was not properly stored', 'ERROR');
                        valid = false;
                    }
                    if (nextRun>0) { finished = true; }
                }
                /*if(dry_run){
                    logMessage("Dry-run enabled; rolling back DB", 'WARN');
                    await link.rollback();
                }else await link.complete();*/

            }catch(e){
                logMessage('Error: ' + e, 'ERROR');
            }
        }
    }
    // update Next Run if successful

    link.end();
   
})();


